\chapter{Implementation Details}
\paragraph{In this chapter} we dive into the implementation details of the selection hyper-heuristic with parameter control.
 
The best practice in software engineering is to minimize an effort for the implementation and reuse already existing and well-tested code.
With this idea in mind we had decided to reuse one of existing (and highlighted by us in \ref{bg: parameter tuning}) open-source hyper-parameter tuning systems as the code basis and those turn it into the core of hyper-heuristic. 
Do to so we analyze the existing systems and highlight important non-functional characteristics from the implementation perspective in section \ref{implementation:hh code basis section}. Since the selected code base system is not the ideal in terms of such features as Search Space entity abilities and the prediction process, we consider some adaptations in sections \ref{implementation: search space} and \ref{implementation: prediction logic} respectively.
We also reuse the set of Low Level Heuristics in section \ref{implementation:llh code basis selection}.


\section{Hyper-Heuristics Code Base Selection}\label{implementation:hh code basis section}
A.k.a. "brain". Need to find a better way to call this part of HH..
\subsection{Requirements}
\subsection{Parameter Tuning Frameworks}
\paragraph{SMAC}
\paragraph{BOHB}

% TODO: it is more for concept description
% Even if fix of Configuration sampling in such cases is relatively simple task (parent-child relationship utilized in IRACE), then building proper density distributions of `good' parameters reflecting conditions is hard.


\paragraph{IRACE}
\paragraph{BRISEv2}
\todoy{Maybe, smth else..}

% TODO: implementation \item[Support for Online Problem Solving.] This is a bit complex characteristic of system that we are willing to distinguish. As it turns out, most parameter tuning systems require full evaluation of Target System for Configuration comparison. However, in case of Hyper-Heuristic, the Configuration evaluation is a trial to solve the problem in hand using particular $LLH$ (tuned parameter) Here we compare final result quality, reported by each $LLH$
\subsection{Conclusion}
BRISEv2 is the best system for code basis, however it has to be changed as we describe in following sections.


\section{Search Space}\label{implementation: search space}

\subsection{Base Version Description}
What is the problem with the current Search Space?
\paragraph{The Scope Refinement Work} Throw away and write a new one :D

\subsection{Implementation}
\paragraph{Description}
\paragraph{Motivation of structure}
\paragraph{Class diagram} - i think, I will put it into the appendix


\section{Prediction Logic}\label{implementation: prediction logic}
\subsection{Base Version Description}
\paragraph{The Scope Refinement Work} prediction should be done in feature-tree structured search space. Most models could handle only flat search space and we would like to enable reuse of those existing models. Though we decouple the structure of Search Space in entity \textbf{Predictor}, while actual prediction process is done in underlying models, that Predictor uses.

\subsection{Predictor}
to decouple prediction from structure of search space.

\subsection{Prediction Models}
\subsubsection{Tree parzen estimator}
\subsubsection{Multi Armed Bandit}
\subsubsection{Sklearn linear regression wrapper}


\section{Data Preprocessing}
\subsection{Heterogeneous Data} description and motivation of data preprocessing notions

\subsection{Base Version Description} and Scope of work analysis
\subsection{Wrapper for Scikit-learn Preprocessors}


\section{Low Level Heuristics}\label{Impl: LLH}

\subsection{Requirements}

\subsection{Code Base Selection}\label{implementation:llh code basis selection}
Available Meta-heuristics with description of their current state
With the aim of effort reuse, the code base should be selected for implementation of the designed hyper-heuristic approach.
% https://docs.google.com/spreadsheets/d/19xjL_ire0R5VLP9seCE5_4sWorSMZP4xvgx7d1q4a9s/edit#gid=0
\paragraph{SOLID}
\paragraph{MLRose}
\paragraph{OR-tools}
\paragraph{pyTSP}
\paragraph{LocalSolver}
\paragraph{jMetalPy}

\subsection{Scope of work analysis}
\paragraph{opened PR}

\section{Conclusion}
